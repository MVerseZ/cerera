# Pallada VM - Виртуальная машина

Pallada VM - это стековая виртуальная машина, разработанная для выполнения байткода. Она поддерживает 256-битные слова и предоставляет набор инструкций для выполнения различных операций.

## Архитектура

### Стековая машина
VM использует стековую архитектуру, где все операции работают со стеком значений. Это означает, что операнды берутся со стека, а результаты помещаются обратно на стек.

### Компоненты

1. **Stack (Стек)** - хранит значения типа `*big.Int` (256-битные числа)
   - Максимальная глубина: 1024 элемента
   - Поддерживает операции: Push, Pop, Peek, Dup, Swap

2. **Memory (Память)** - байтовый массив для хранения данных
   - Максимальный размер: 64 KB
   - Поддерживает операции: Set, Get, Set32, Get32

3. **VM (Виртуальная машина)** - основной компонент
   - Выполняет байткод
   - Управляет стеком и памятью
   - Отслеживает счетчик команд (PC)

## Опкоды (Инструкции)

### Остановка выполнения
- `STOP (0x00)` - останавливает выполнение

### Арифметические операции
- `ADD (0x01)` - сложение: `a + b`
- `SUB (0x02)` - вычитание: `a - b`
- `MUL (0x03)` - умножение: `a * b`
- `DIV (0x04)` - деление: `a / b` (при делении на 0 возвращает 0)
- `MOD (0x05)` - остаток от деления: `a % b` (при делении на 0 возвращает 0)

### Логические операции
- `AND (0x10)` - побитовое И: `a & b`
- `OR (0x11)` - побитовое ИЛИ: `a | b`
- `XOR (0x12)` - побитовое исключающее ИЛИ: `a ^ b`
- `NOT (0x13)` - побитовое НЕ: `~a`

### Операции сравнения
- `LT (0x20)` - меньше: `a < b` (возвращает 1 или 0)
- `GT (0x21)` - больше: `a > b` (возвращает 1 или 0)
- `EQ (0x22)` - равно: `a == b` (возвращает 1 или 0)
- `ISZERO (0x23)` - проверка на ноль: `a == 0` (возвращает 1 или 0)

### Операции со стеком
- `POP (0x30)` - удалить верхний элемент стека
- `DUP1-DUP4 (0x40-0x43)` - дублировать n-й элемент с верха
- `SWAP1-SWAP4 (0x50-0x53)` - поменять местами верхний и n-й элемент

### Операции с памятью
- `MLOAD (0x60)` - загрузить слово (32 байта) из памяти на стек
- `MSTORE (0x61)` - сохранить слово (32 байта) из стека в память

### PUSH операции (загрузка констант)
- `PUSH1 (0x70)` - загрузить 1 байт на стек
- `PUSH2 (0x71)` - загрузить 2 байта на стек
- `PUSH4 (0x72)` - загрузить 4 байта на стек
- `PUSH8 (0x73)` - загрузить 8 байт на стек
- `PUSH16 (0x74)` - загрузить 16 байт на стек
- `PUSH32 (0x75)` - загрузить 32 байта на стек (полное слово)

### Управление потоком
- `JUMP (0x80)` - безусловный переход к адресу со стека
- `JUMPI (0x81)` - условный переход (если условие != 0)
- `JUMPDEST (0x82)` - метка для перехода (NOP)
- `PC (0x83)` - получить текущий счетчик команд на стек
- `RETURN (0x84)` - вернуть данные из памяти
- `REVERT (0x85)` - откатить выполнение с данными из памяти

## Использование

### Базовый пример

```go
package main

import (
    "fmt"
    "github.com/cerera/internal/pallada/pallada"
)

func main() {
    // Байткод: PUSH1 5, PUSH1 3, ADD, STOP
    code := []byte{
        byte(pallada.PUSH1), 0x05, // PUSH1 5
        byte(pallada.PUSH1), 0x03, // PUSH1 3
        byte(pallada.ADD),         // ADD
        byte(pallada.STOP),        // STOP
    }

    vm := pallada.NewVM(code)
    result, err := vm.Run()
    
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
        return
    }

    // Получаем результат со стека
    stackValue, _ := vm.GetStack().Pop()
    fmt.Printf("Результат: %v\n", stackValue) // Выведет: 8
}
```

### Пример с памятью

```go
// Байткод: PUSH1 0x42, PUSH1 0, MSTORE, PUSH1 0, MLOAD, STOP
code := []byte{
    byte(pallada.PUSH1), 0x42, // PUSH1 0x42
    byte(pallada.PUSH1), 0x00, // PUSH1 0 (offset)
    byte(pallada.MSTORE),      // MSTORE
    byte(pallada.PUSH1), 0x00, // PUSH1 0 (offset)
    byte(pallada.MLOAD),       // MLOAD
    byte(pallada.STOP),        // STOP
}

vm := pallada.NewVM(code)
_, err := vm.Run()

stackValue, _ := vm.GetStack().Pop()
fmt.Printf("Значение из памяти: %v\n", stackValue) // Выведет: 66 (0x42)
```

### Пример с условным переходом

```go
// Байткод: PUSH1 8, PUSH1 1, JUMPI, PUSH1 0, STOP, JUMPDEST, PUSH1 42, STOP
code := []byte{
    byte(pallada.PUSH1), 0x08, // PUSH1 8 (адрес JUMPDEST)
    byte(pallada.PUSH1), 0x01, // PUSH1 1 (условие)
    byte(pallada.JUMPI),       // JUMPI
    byte(pallada.PUSH1), 0x00, // PUSH1 0 (не выполнится)
    byte(pallada.STOP),        // STOP
    byte(pallada.JUMPDEST),    // JUMPDEST (позиция 8)
    byte(pallada.PUSH1), 0x2a, // PUSH1 42
    byte(pallada.STOP),        // STOP
}

vm := pallada.NewVM(code)
_, err := vm.Run()

stackValue, _ := vm.GetStack().Pop()
fmt.Printf("Результат: %v\n", stackValue) // Выведет: 42
```

## Формат байткода

Байткод представляет собой последовательность байтов, где каждый байт (или последовательность байтов для PUSH) представляет инструкцию.

### Структура инструкции

1. **Обычные инструкции**: один байт - опкод
2. **PUSH инструкции**: опкод + N байт данных (где N зависит от типа PUSH)

### Примеры байткода

```
PUSH1 5    -> [0x70, 0x05]
ADD        -> [0x01]
STOP       -> [0x00]
```

## Ограничения

- **Глубина стека**: максимум 1024 элемента
- **Размер памяти**: максимум 64 KB
- **Размер слова**: 256 бит (32 байта)
- **Размер байткода**: ограничен только доступной памятью

## Ошибки

VM может вернуть следующие ошибки:

- `ErrStackUnderflow` - попытка извлечь элемент из пустого стека
- `ErrStackOverflow` - попытка добавить элемент в переполненный стек
- `ErrMemoryOutOfBounds` - попытка обратиться к памяти за пределами допустимого
- `ErrInvalidOpcode` - невалидный опкод
- `ErrInvalidJump` - невалидный адрес перехода
- `ErrInvalidBytecode` - невалидный формат байткода

## Оптимизации

VM включает несколько оптимизаций производительности:

1. **Предварительное выделение памяти** - стек и память создаются с увеличенной начальной емкостью
2. **Кэширование констант** - часто используемые значения (0, 1) создаются заранее
3. **Оптимизация цикла выполнения** - кэширование длины кода и быстрая проверка опкодов
4. **Эффективное управление памятью** - умное расширение памяти с предварительным выделением

## Тестирование

Все компоненты VM покрыты тестами. Запуск тестов:

```bash
go test ./internal/pallada/pallada -v
```

## Лицензия

Этот код является частью проекта Cerera.
